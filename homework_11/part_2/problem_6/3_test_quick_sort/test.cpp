using namespace std;

#include <vector>
#include <ctime>
#include <cstdlib>
#include <iostream>


int randomPivot(int s, int r)
{
    return s + 100 % (r - s + 1);
}

void printPivotIndex(vector<int> nums, int pivotIndex)
{
    cout << "Pivot Index: " << pivotIndex << ", Pivot Value: "<< nums[pivotIndex] << endl;
    cout << "Partitioned Array: ";
    for (int num : nums)
        cout << num << " ";
    cout << endl << endl;
}


int randomPartition(vector<int>& nums, int s, int e)
{
    int pivotIndex = randomPivot(s, e);
    cout << "Range: (" << s << ", " << e << ")";
    printPivotIndex(nums, pivotIndex);

    // move pivot to end
    swap(nums[pivotIndex], nums[e]);

    int pivot = nums[e];
    int i = s - 1;

    for(int j = s; j < e; j++)
    {
        if(nums[j] <= pivot)
        {
            i++;
            swap(nums[i], nums[j]);
        }
    }
    // move pivot index
    swap(nums[i+1], nums[e]);
    return i+1;
}

void quickSort(vector<int>& nums, int s, int e)
{
    if(s > e)
        return;

    int p = randomPartition(nums, s, e);
    quickSort(nums, s, p - 1);
    quickSort(nums, p + 1, e);
}

int main() 
{
    vector<int> arr = {3, 8, 1, 4, 7, 2, 9, 5, 6};
    int n = arr.size();

    quickSort(arr, 0, n-1);
    cout << "Sorted Array: ";
    for (int num : arr)
        cout << num << " ";
}

/*
Analysis:
The issue I foud is: 
If you set the range value to be 100, the random pivot index generated by 
randomIndex = start + 100 % (end - start + 1) always end up to selecting 
a pivot element that is already very close to the start and end of the array. Also,
it generates the same pivot index for the same range. Its not random anymore. 
This leads us to skewed partitions in every recursive call, causing the algorithm 
to run O(n^2) in worst case.
*/